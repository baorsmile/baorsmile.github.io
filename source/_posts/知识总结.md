title: 知识总结
date: 2017-07-17 17:30:31
tags: iOS
category:
---

# KVO
## 坑
* 可以对同一个属性就行多次添加，在监听回掉里里面会接受到多个添加的kepath, 也就是说添加了几个回调几个；在rmove时候也是，添加了几个就remvoe几个，不管是否是同一个属性
* 如果你添加一个属性，但是你remove了两次，就会crash，**这里强调一点，如果你对一个属性添加了多次，你就要remove多次，这是不会crash的**
* 防止remove掉父类的你需要在add时候添加一个上下文context，来进行标记是否是自己添加，再在remove的时候remove掉自己的就行了

## 实现方式
* 当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。自然，重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。

# GCG
## dispatch_apply，循环多少次
### 应用场景
* 要处理大数据时候使用apply会比多开线程来的好
* 如果我们从服务器获取一个数组的数据，那么我们可以使用该方法从而快速的批量字典转模型。
```
NSArray *dictArray = nil;//存放从服务器返回的字典数组

    dispatch_queue_t queue = dispatch_queue_create("queue", DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(queue, ^{

        dispatch_apply(dictArray.count, queue,  ^(size_t index){
            //字典转模型

        });
        dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@"主线程更新");
        });
    });
```

> 作者：lltree
转自：http://www.jianshu.com/p/3b12bb90bb15





### dispatch_barrier_async/dispatch_barrier_sync，屏障
* DISPATCH_QUEUE_CONCURRENT 队列中才起作用,在全局并发队列 dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) 中无效,也就是说起不到屏障的作用

* 放到子线程里面做dispatch_barrier_sync，发现不起作用，也不会打印block里面的内容，但是用dispatch_barrier_async是可以的

```
dispatch_queue_t concurrent_queue = dispatch_queue_create("concurrent_queue", DISPATCH_QUEUE_CONCURRENT);

dispatch_async(concurrent_queue, ^(){
    NSLog(@"task-1--%@",[NSThread currentThread]);
});
dispatch_async(concurrent_queue, ^(){
    NSLog(@"task-2--%@",[NSThread currentThread]);
});
dispatch_sync(concurrent_queue, ^(){
    NSLog(@"task-3--%@",[NSThread currentThread]);

    dispatch_async(concurrent_queue, ^(){
        NSLog(@"task-5--%@",[NSThread currentThread]);
    });
    dispatch_async(concurrent_queue, ^(){
        NSLog(@"task-6--%@",[NSThread currentThread]);
    });

    dispatch_barrier_async(concurrent_queue, ^(){
        NSLog(@"dispatch_barrier_async--%@",[NSThread currentThread]);
    });

    dispatch_async(concurrent_queue, ^(){
        NSLog(@"task-4--%@",[NSThread currentThread]);
    });
});

2017-07-17 19:08:17.998 BackBlock[32724:28690837] task-3--<NSThread: 0x618000066040>{number = 1, name = main}
2017-07-17 19:08:17.998 BackBlock[32724:28691040] task-2--<NSThread: 0x61000006bbc0>{number = 4, name = (null)}
2017-07-17 19:08:17.998 BackBlock[32724:28691038] task-1--<NSThread: 0x618000068980>{number = 3, name = (null)}
2017-07-17 19:08:17.999 BackBlock[32724:28691042] task-5--<NSThread: 0x6180000690c0>{number = 5, name = (null)}
2017-07-17 19:08:17.999 BackBlock[32724:28691057] task-6--<NSThread: 0x60800006c340>{number = 6, name = (null)}
2017-07-17 19:08:17.999 BackBlock[32724:28691057] dispatch_barrier_async--<NSThread: 0x60800006c340>{number = 6, name = (null)}
2017-07-17 19:08:17.999 BackBlock[32724:28691057] task-4--<NSThread: 0x60800006c340>{number = 6, name = (null)}
```
